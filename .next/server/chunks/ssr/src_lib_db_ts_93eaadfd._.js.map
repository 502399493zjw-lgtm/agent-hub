{"version":3,"sources":["../../../../src/lib/db.ts","../../../../src/data/seed.ts"],"sourcesContent":["import Database from 'better-sqlite3';\nimport path from 'path';\nimport { Asset, User } from '@/data/mock';\nimport { inviteCodes } from '@/data/seed';\n\nconst DB_PATH = path.join(process.cwd(), 'data', 'hub.db');\n\nlet _db: Database.Database | null = null;\n\nfunction getDb(): Database.Database {\n  if (!_db) {\n    _db = new Database(DB_PATH);\n    _db.pragma('journal_mode = WAL');\n    initTables(_db);\n  }\n  return _db;\n}\n\n// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n// Hub Score â€” REMOVED (v3: display installs directly)\n// calculateHubScore kept only for internal DB column compat\n// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n\nexport function calculateHubScore(_downloads: number, _rating: number, _ratingCount: number): {\n  hubScore: number;\n  hubScoreBreakdown: { downloadScore: number; maintenanceScore: number; reputationScore: number };\n} {\n  return { hubScore: 0, hubScoreBreakdown: { downloadScore: 0, maintenanceScore: 0, reputationScore: 0 } };\n}\n\n// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n// Coin System â€” Event Values\n// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n\n// User reputation events (honor currency, only goes up)\nconst USER_REP_EVENTS = {\n  publish_asset:   20,\n  asset_installed:  3,\n  asset_rated_good: 5,  // 4-5 star\n  issue_closed:     5,\n  write_comment:    2,\n  submit_issue:     2,\n  invite_user:     10,\n  new_version:      8,\n} as const;\n\n// Shrimp coins events (spendable currency)\nconst SHRIMP_COIN_EVENTS = {\n  register:        100,  // welcome bonus\n  daily_login:       5,\n  publish_asset:    50,\n  asset_installed:  10,\n  asset_rated_5star: 15,\n  write_comment:     3,\n  submit_issue:      5,\n  invite_user:      30,\n  new_version:      20,\n} as const;\n\nexport function recalculateHubScore(assetId: string): void {\n  const db = getDb();\n  const row = db.prepare('SELECT downloads, rating, rating_count FROM assets WHERE id = ?').get(assetId) as { downloads: number; rating: number; rating_count: number } | undefined;\n  if (!row) return;\n  const { hubScore, hubScoreBreakdown } = calculateHubScore(row.downloads, row.rating, row.rating_count);\n  db.prepare('UPDATE assets SET hub_score = ?, hub_score_breakdown = ? WHERE id = ?').run(\n    hubScore, JSON.stringify(hubScoreBreakdown), assetId\n  );\n}\n\nexport function incrementDownload(assetId: string): number | null {\n  const db = getDb();\n  const result = db.prepare('UPDATE assets SET downloads = downloads + 1 WHERE id = ?').run(assetId);\n  if (result.changes === 0) return null;\n  recalculateHubScore(assetId);\n\n  // Award coins to asset author\n  const asset = db.prepare('SELECT author_id, downloads FROM assets WHERE id = ?').get(assetId) as { author_id: string; downloads: number } | undefined;\n  if (asset?.author_id) {\n    addCoins(asset.author_id, 'reputation', USER_REP_EVENTS.asset_installed, 'asset_installed', assetId);\n    addCoins(asset.author_id, 'shrimp_coin', SHRIMP_COIN_EVENTS.asset_installed, 'asset_installed', assetId);\n  }\n  return asset?.downloads ?? null;\n}\n\n// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n// Coin System â€” Reputation & Shrimp Coins\n// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n\nexport function addCoins(userId: string, coinType: 'reputation' | 'shrimp_coin', amount: number, event: string, refId?: string): void {\n  const db = getDb();\n  const col = coinType === 'reputation' ? 'reputation' : 'shrimp_coins';\n\n  // Check user exists\n  const user = db.prepare(`SELECT ${col} FROM users WHERE id = ?`).get(userId) as Record<string, number> | undefined;\n  if (!user) return;\n\n  const currentBalance = user[col] ?? 0;\n  const newBalance = Math.max(0, currentBalance + amount); // never go below 0\n\n  db.prepare(`UPDATE users SET ${col} = ? WHERE id = ?`).run(newBalance, userId);\n  db.prepare(`INSERT INTO coin_events (user_id, coin_type, amount, event, ref_id, balance_after, created_at) VALUES (?, ?, ?, ?, ?, ?, ?)`).run(\n    userId, coinType, amount, event, refId ?? null, newBalance, new Date().toISOString()\n  );\n}\n\nexport function getUserCoins(userId: string): { reputation: number; shrimpCoins: number } {\n  const row = getDb().prepare('SELECT reputation, shrimp_coins FROM users WHERE id = ?').get(userId) as { reputation: number; shrimp_coins: number } | undefined;\n  return { reputation: row?.reputation ?? 0, shrimpCoins: row?.shrimp_coins ?? 100 };\n}\n\nexport function getCoinHistory(userId: string, coinType?: 'reputation' | 'shrimp_coin', limit: number = 50): { id: number; coinType: string; amount: number; event: string; refId: string | null; balanceAfter: number; createdAt: string }[] {\n  const db = getDb();\n  let sql = 'SELECT * FROM coin_events WHERE user_id = ?';\n  const params: (string | number)[] = [userId];\n  if (coinType) {\n    sql += ' AND coin_type = ?';\n    params.push(coinType);\n  }\n  sql += ' ORDER BY id DESC LIMIT ?';\n  params.push(limit);\n  const rows = db.prepare(sql).all(...params) as { id: number; user_id: string; coin_type: string; amount: number; event: string; ref_id: string | null; balance_after: number; created_at: string }[];\n  return rows.map(r => ({ id: r.id, coinType: r.coin_type, amount: r.amount, event: r.event, refId: r.ref_id, balanceAfter: r.balance_after, createdAt: r.created_at }));\n}\n\nexport function hasEnoughCoins(userId: string, amount: number): boolean {\n  const { shrimpCoins } = getUserCoins(userId);\n  return shrimpCoins >= amount;\n}\n\n// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n// Table creation\n// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n\nfunction initTables(db: Database.Database): void {\n  db.exec(`\n    CREATE TABLE IF NOT EXISTS assets (\n      id TEXT PRIMARY KEY, name TEXT NOT NULL, display_name TEXT NOT NULL,\n      type TEXT NOT NULL CHECK(type IN ('skill','channel','plugin','trigger','config','template')),\n      author_id TEXT NOT NULL DEFAULT '', author_name TEXT NOT NULL DEFAULT '', author_avatar TEXT NOT NULL DEFAULT '',\n      description TEXT NOT NULL DEFAULT '', long_description TEXT NOT NULL DEFAULT '',\n      version TEXT NOT NULL DEFAULT '1.0.0', downloads INTEGER NOT NULL DEFAULT 0,\n      rating REAL NOT NULL DEFAULT 0, rating_count INTEGER NOT NULL DEFAULT 0,\n      tags TEXT NOT NULL DEFAULT '[]', category TEXT NOT NULL DEFAULT '',\n      created_at TEXT NOT NULL DEFAULT '', updated_at TEXT NOT NULL DEFAULT '',\n      install_command TEXT NOT NULL DEFAULT '', readme TEXT NOT NULL DEFAULT '',\n      versions TEXT NOT NULL DEFAULT '[]', dependencies TEXT NOT NULL DEFAULT '[]',\n      issue_count INTEGER NOT NULL DEFAULT 0, config_subtype TEXT,\n      hub_score INTEGER NOT NULL DEFAULT 70, hub_score_breakdown TEXT NOT NULL DEFAULT '{}',\n      upgrade_rate REAL NOT NULL DEFAULT 50, compatibility TEXT NOT NULL DEFAULT '{}',\n      files TEXT NOT NULL DEFAULT '[]'\n    );\n    CREATE TABLE IF NOT EXISTS users (\n      id TEXT PRIMARY KEY, email TEXT UNIQUE, name TEXT NOT NULL, avatar TEXT DEFAULT '',\n      provider TEXT NOT NULL, provider_id TEXT NOT NULL, bio TEXT DEFAULT '',\n      invite_code TEXT, created_at TEXT NOT NULL, updated_at TEXT NOT NULL, deleted_at TEXT,\n      UNIQUE(provider, provider_id)\n    );\n    CREATE TABLE IF NOT EXISTS invite_codes (\n      code TEXT PRIMARY KEY, created_by TEXT DEFAULT 'system', used_by TEXT, used_at TEXT,\n      max_uses INTEGER DEFAULT 1, use_count INTEGER DEFAULT 0, expires_at TEXT, created_at TEXT NOT NULL,\n      type TEXT NOT NULL DEFAULT 'normal'\n    );\n    CREATE TABLE IF NOT EXISTS user_profiles (\n      id TEXT PRIMARY KEY, name TEXT NOT NULL, avatar TEXT NOT NULL DEFAULT '', bio TEXT NOT NULL DEFAULT '',\n      joined_at TEXT NOT NULL DEFAULT '', published_assets TEXT NOT NULL DEFAULT '[]',\n      favorite_assets TEXT NOT NULL DEFAULT '[]', followers INTEGER NOT NULL DEFAULT 0,\n      following INTEGER NOT NULL DEFAULT 0, is_agent BOOLEAN NOT NULL DEFAULT 0,\n      agent_model TEXT, agent_uptime TEXT, agent_tasks_completed INTEGER NOT NULL DEFAULT 0,\n      agent_specialization TEXT, contribution_points INTEGER NOT NULL DEFAULT 0,\n      contributor_level TEXT NOT NULL DEFAULT 'newcomer', instance_id TEXT\n    );\n    CREATE TABLE IF NOT EXISTS comments (\n      id TEXT PRIMARY KEY, asset_id TEXT NOT NULL, user_id TEXT NOT NULL,\n      user_name TEXT, user_avatar TEXT, content TEXT, rating INTEGER,\n      created_at TEXT, commenter_type TEXT NOT NULL DEFAULT 'user'\n    );\n    CREATE TABLE IF NOT EXISTS issues (\n      id TEXT PRIMARY KEY, asset_id TEXT NOT NULL, author_id TEXT,\n      author_name TEXT, author_avatar TEXT, author_type TEXT NOT NULL DEFAULT 'user',\n      title TEXT, body TEXT, status TEXT NOT NULL DEFAULT 'open',\n      labels TEXT NOT NULL DEFAULT '[]', created_at TEXT, comment_count INTEGER NOT NULL DEFAULT 0\n    );\n    CREATE TABLE IF NOT EXISTS collections (\n      id TEXT PRIMARY KEY, title TEXT, description TEXT,\n      curator_id TEXT, curator_name TEXT, curator_avatar TEXT,\n      asset_ids TEXT NOT NULL DEFAULT '[]', cover_emoji TEXT,\n      followers INTEGER NOT NULL DEFAULT 0, created_at TEXT\n    );\n    CREATE TABLE IF NOT EXISTS notifications (\n      id TEXT PRIMARY KEY, user_id TEXT NOT NULL DEFAULT 'self', type TEXT,\n      title TEXT, message TEXT, icon TEXT, link_to TEXT,\n      is_read BOOLEAN NOT NULL DEFAULT 0, created_at TEXT\n    );\n    CREATE TABLE IF NOT EXISTS evolution_events (\n      id TEXT PRIMARY KEY, user_id TEXT NOT NULL, icon TEXT,\n      title TEXT, description TEXT, date TEXT, type TEXT\n    );\n    CREATE TABLE IF NOT EXISTS activity_events (\n      id TEXT PRIMARY KEY, user_id TEXT NOT NULL, icon TEXT,\n      text TEXT, date TEXT, type TEXT, link_to TEXT,\n      actor_type TEXT NOT NULL DEFAULT 'user'\n    );\n    CREATE TABLE IF NOT EXISTS authorized_devices (\n      device_id TEXT PRIMARY KEY,\n      user_id TEXT NOT NULL,\n      name TEXT NOT NULL DEFAULT '',\n      authorized_at TEXT NOT NULL,\n      last_publish_at TEXT,\n      FOREIGN KEY (user_id) REFERENCES users(id)\n    );\n    CREATE TABLE IF NOT EXISTS verification_tokens (\n      identifier TEXT NOT NULL,\n      token TEXT NOT NULL,\n      expires TEXT NOT NULL,\n      PRIMARY KEY (identifier, token)\n    );\n    CREATE TABLE IF NOT EXISTS daily_stats (\n      day INTEGER PRIMARY KEY, downloads INTEGER NOT NULL DEFAULT 0,\n      new_assets INTEGER NOT NULL DEFAULT 0, new_users INTEGER NOT NULL DEFAULT 0\n    );\n    CREATE TABLE IF NOT EXISTS coin_events (\n      id INTEGER PRIMARY KEY AUTOINCREMENT,\n      user_id TEXT NOT NULL,\n      coin_type TEXT NOT NULL CHECK(coin_type IN ('reputation', 'shrimp_coin')),\n      amount INTEGER NOT NULL,\n      event TEXT NOT NULL,\n      ref_id TEXT,\n      balance_after INTEGER NOT NULL DEFAULT 0,\n      created_at TEXT NOT NULL\n    );\n    CREATE INDEX IF NOT EXISTS idx_coin_events_user ON coin_events(user_id, coin_type);\n    CREATE INDEX IF NOT EXISTS idx_coin_events_ref ON coin_events(ref_id);\n  `);\n\n  // Migration: add reputation and shrimp_coins columns to users table if missing\n  try {\n    db.exec(`ALTER TABLE users ADD COLUMN reputation INTEGER NOT NULL DEFAULT 0`);\n  } catch { /* column already exists */ }\n  try {\n    db.exec(`ALTER TABLE users ADD COLUMN shrimp_coins INTEGER NOT NULL DEFAULT 100`);\n  } catch { /* column already exists */ }\n  // Migration: add onboarding + custom profile columns\n  try {\n    db.exec(`ALTER TABLE users ADD COLUMN onboarding_completed INTEGER NOT NULL DEFAULT 0`);\n  } catch { /* column already exists */ }\n  try {\n    db.exec(`ALTER TABLE users ADD COLUMN custom_name TEXT`);\n  } catch { /* column already exists */ }\n  try {\n    db.exec(`ALTER TABLE users ADD COLUMN custom_avatar TEXT`);\n  } catch { /* column already exists */ }\n  try {\n    db.exec(`ALTER TABLE users ADD COLUMN provider_name TEXT`);\n  } catch { /* column already exists */ }\n  try {\n    db.exec(`ALTER TABLE users ADD COLUMN provider_avatar TEXT`);\n  } catch { /* column already exists */ }\n  // Migration: add manifest column to assets\n  try {\n    db.exec(`ALTER TABLE assets ADD COLUMN manifest TEXT NOT NULL DEFAULT '{}'`);\n  } catch { /* column already exists */ }\n\n  // Seed invite codes if empty\n  const inviteCount = db.prepare('SELECT COUNT(*) as cnt FROM invite_codes').get() as { cnt: number };\n  if (inviteCount.cnt === 0) {\n    const now = new Date().toISOString();\n    const insertCode = db.prepare(`INSERT OR IGNORE INTO invite_codes (code, created_by, max_uses, use_count, type, created_at) VALUES (?, 'system', ?, 0, ?, ?)`);\n    for (const c of inviteCodes) {\n      insertCode.run(c.code, c.maxUses, c.type ?? 'system', now);\n    }\n  }\n}\n\n// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n// Asset row conversion\n// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n\nexport interface DbRow {\n  id: string; name: string; display_name: string; type: string;\n  author_id: string; author_name: string; author_avatar: string;\n  description: string; long_description: string; version: string;\n  downloads: number; rating: number; rating_count: number;\n  tags: string; category: string; created_at: string; updated_at: string;\n  install_command: string; readme: string; versions: string; dependencies: string;\n  issue_count: number; config_subtype: string | null;\n  hub_score: number; hub_score_breakdown: string; upgrade_rate: number;\n  compatibility: string; files: string;\n  github_url: string; github_stars: number; github_forks: number;\n  github_language: string; github_license: string; github_synced_at: string;\n}\n\nexport function rowToAsset(row: DbRow): Asset {\n  return {\n    id: row.id, name: row.name, displayName: row.display_name,\n    type: row.type as Asset['type'],\n    author: { id: row.author_id || ('u-' + row.author_name.toLowerCase().replace(/\\s+/g, '-')), name: row.author_name, avatar: row.author_avatar },\n    description: row.description, longDescription: row.long_description, version: row.version,\n    downloads: row.downloads, rating: row.rating, ratingCount: row.rating_count,\n    tags: JSON.parse(row.tags) as string[], category: row.category,\n    createdAt: row.created_at, updatedAt: row.updated_at,\n    installCommand: row.install_command, readme: row.readme,\n    versions: JSON.parse(row.versions), dependencies: JSON.parse(row.dependencies),\n    compatibility: JSON.parse(row.compatibility), issueCount: row.issue_count,\n    files: JSON.parse(row.files || '[]'),\n    configSubtype: (row.config_subtype ?? undefined) as Asset['configSubtype'],\n    githubUrl: row.github_url || undefined,\n    githubStars: row.github_stars || undefined,\n    githubForks: row.github_forks || undefined,\n  };\n}\n\nfunction assetToRow(a: Asset) {\n  const { hubScore, hubScoreBreakdown } = calculateHubScore(a.downloads, a.rating, a.ratingCount);\n  return {\n    id: a.id, name: a.name, display_name: a.displayName, type: a.type,\n    author_id: a.author.id, author_name: a.author.name, author_avatar: a.author.avatar,\n    description: a.description, long_description: a.longDescription, version: a.version,\n    downloads: a.downloads, rating: a.rating, rating_count: a.ratingCount,\n    tags: JSON.stringify(a.tags), category: a.category,\n    created_at: a.createdAt, updated_at: a.updatedAt,\n    install_command: a.installCommand, readme: a.readme,\n    versions: JSON.stringify(a.versions), dependencies: JSON.stringify(a.dependencies),\n    issue_count: a.issueCount, config_subtype: a.configSubtype ?? null,\n    files: JSON.stringify(a.files ?? []),\n    hub_score: hubScore, hub_score_breakdown: JSON.stringify(hubScoreBreakdown),\n    upgrade_rate: 0, compatibility: JSON.stringify(a.compatibility ?? {}),\n  };\n}\n\n// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n// Public API â€” Assets\n// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n\nexport interface ListParams {\n  type?: string; category?: string; q?: string; sort?: string; page?: number; pageSize?: number;\n}\n\nexport function listAssets(params: ListParams): { assets: Asset[]; total: number; page: number; pageSize: number } {\n  const db = getDb();\n  const conditions: string[] = [];\n  const bindings: Record<string, string | number> = {};\n\n  if (params.type && ['skill','config','plugin','trigger','channel','template'].includes(params.type)) {\n    conditions.push('type = @type'); bindings.type = params.type;\n  }\n  if (params.category) { conditions.push('category = @category'); bindings.category = params.category; }\n  if (params.q) {\n    conditions.push(`(name LIKE @q OR display_name LIKE @q OR description LIKE @q OR tags LIKE @q)`);\n    bindings.q = `%${params.q}%`;\n  }\n  const where = conditions.length > 0 ? 'WHERE ' + conditions.join(' AND ') : '';\n  const total = (db.prepare(`SELECT COUNT(*) as cnt FROM assets ${where}`).get(bindings) as { cnt: number }).cnt;\n\n  let orderBy: string;\n  switch (params.sort) {\n    case 'downloads': orderBy = 'downloads DESC'; break;\n    case 'rating': orderBy = 'rating DESC'; break;\n    case 'updated_at': case 'newest': orderBy = 'updated_at DESC'; break;\n    case 'created_at': orderBy = 'created_at DESC'; break;\n    case 'trending': orderBy = 'downloads DESC, updated_at DESC'; break;\n    default: orderBy = '(downloads * rating) DESC';\n  }\n  const page = Math.max(1, params.page ?? 1);\n  const pageSize = Math.min(100, Math.max(1, params.pageSize ?? 20));\n  const offset = (page - 1) * pageSize;\n  const rows = db.prepare(`SELECT * FROM assets ${where} ORDER BY ${orderBy} LIMIT @limit OFFSET @offset`).all({ ...bindings, limit: pageSize, offset }) as DbRow[];\n  return { assets: rows.map(rowToAsset), total, page, pageSize };\n}\n\nexport function getAssetById(id: string): Asset | null {\n  const db = getDb();\n  const row = db.prepare('SELECT * FROM assets WHERE id = ?').get(id) as DbRow | undefined;\n  return row ? rowToAsset(row) : null;\n}\n\nexport function createAsset(data: {\n  name: string; displayName: string; type: string; description: string; version: string;\n  authorId?: string; authorName?: string; authorAvatar?: string;\n  longDescription?: string; tags?: string[]; category?: string; readme?: string; configSubtype?: string;\n}): Asset {\n  const db = getDb();\n  const typePrefixes: Record<string, string> = { skill: 's', config: 'c', plugin: 'p', trigger: 'tr', channel: 'ch', template: 't' };\n  const prefix = typePrefixes[data.type] || 'x';\n  const id = `${prefix}-${Math.random().toString(36).substring(2, 8)}`;\n  const now = new Date().toISOString().split('T')[0];\n  const authorName = data.authorName || 'CyberNova';\n  const authorAvatar = data.authorAvatar || 'ğŸ¤–';\n  const authorId = data.authorId || ('u-' + authorName.toLowerCase().replace(/\\s+/g, '-'));\n\n  // Calculate initial hub score (0 downloads, 0 ratings)\n  const { hubScore, hubScoreBreakdown } = calculateHubScore(0, 0, 0);\n\n  const asset: Asset = {\n    id, name: data.name, displayName: data.displayName, type: data.type as Asset['type'],\n    author: { id: authorId, name: authorName, avatar: authorAvatar },\n    description: data.description, longDescription: data.longDescription || '',\n    version: data.version, downloads: 0, rating: 0, ratingCount: 0,\n    tags: data.tags || [], category: data.category || '',\n    createdAt: now, updatedAt: now,\n    installCommand: `seafood-market install ${data.type}/@${authorId}/${data.name}`,\n    readme: data.readme || '',\n    versions: [{ version: data.version, changelog: 'é¦–æ¬¡å‘å¸ƒ', date: now }],\n    dependencies: [], compatibility: { models: ['GPT-4','Claude 3'], platforms: ['OpenClaw'], frameworks: ['Node.js'] },\n    issueCount: 0, configSubtype: data.configSubtype as Asset['configSubtype'],\n  };\n  db.prepare(`INSERT INTO assets (id,name,display_name,type,author_id,author_name,author_avatar,description,long_description,version,downloads,rating,rating_count,tags,category,created_at,updated_at,install_command,readme,versions,dependencies,issue_count,config_subtype,hub_score,hub_score_breakdown,upgrade_rate,compatibility,files) VALUES (@id,@name,@display_name,@type,@author_id,@author_name,@author_avatar,@description,@long_description,@version,@downloads,@rating,@rating_count,@tags,@category,@created_at,@updated_at,@install_command,@readme,@versions,@dependencies,@issue_count,@config_subtype,@hub_score,@hub_score_breakdown,@upgrade_rate,@compatibility,@files)`).run(assetToRow(asset));\n\n  // Award coins to publisher\n  if (data.authorId) {\n    addCoins(data.authorId, 'reputation', USER_REP_EVENTS.publish_asset, 'publish_asset', id);\n    addCoins(data.authorId, 'shrimp_coin', SHRIMP_COIN_EVENTS.publish_asset, 'publish_asset', id);\n  }\n\n  return asset;\n}\n\nexport function updateAsset(id: string, data: Partial<{\n  name: string; displayName: string; description: string; longDescription: string;\n  version: string; tags: string[]; category: string; readme: string;\n  authorId: string; authorName: string; authorAvatar: string;\n  files: Array<{ name: string; type: string; size?: number; children?: unknown[]; content?: string }>;\n}>): Asset | null {\n  const db = getDb();\n  const existing = db.prepare('SELECT * FROM assets WHERE id = ?').get(id) as DbRow | undefined;\n  if (!existing) return null;\n  const updates: string[] = [];\n  const bindings: Record<string, string | number> = { id };\n  if (data.name !== undefined) { updates.push('name = @name'); bindings.name = data.name; }\n  if (data.displayName !== undefined) { updates.push('display_name = @dn'); bindings.dn = data.displayName; }\n  if (data.description !== undefined) { updates.push('description = @desc'); bindings.desc = data.description; }\n  if (data.longDescription !== undefined) { updates.push('long_description = @ld'); bindings.ld = data.longDescription; }\n  if (data.version !== undefined) { updates.push('version = @ver'); bindings.ver = data.version; }\n  if (data.tags !== undefined) { updates.push('tags = @tags'); bindings.tags = JSON.stringify(data.tags); }\n  if (data.category !== undefined) { updates.push('category = @cat'); bindings.cat = data.category; }\n  if (data.readme !== undefined) { updates.push('readme = @rm'); bindings.rm = data.readme; }\n  if (data.authorId !== undefined) { updates.push('author_id = @ai'); bindings.ai = data.authorId; }\n  if (data.authorName !== undefined) { updates.push('author_name = @an'); bindings.an = data.authorName; }\n  if (data.authorAvatar !== undefined) { updates.push('author_avatar = @aa'); bindings.aa = data.authorAvatar; }\n  if ((data as { files?: unknown }).files !== undefined) { updates.push('files = @files'); bindings.files = JSON.stringify((data as { files: unknown }).files); }\n  updates.push('updated_at = @ua'); bindings.ua = new Date().toISOString().split('T')[0];\n  db.prepare(`UPDATE assets SET ${updates.join(', ')} WHERE id = @id`).run(bindings);\n  return rowToAsset(db.prepare('SELECT * FROM assets WHERE id = ?').get(id) as DbRow);\n}\n\nexport function deleteAsset(id: string): boolean {\n  return getDb().prepare('DELETE FROM assets WHERE id = ?').run(id).changes > 0;\n}\n\n// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n// Public API â€” Auth Users (OAuth)\n// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n\nexport interface DbUser {\n  id: string; email: string | null; name: string; avatar: string;\n  provider: string; provider_id: string; bio: string;\n  invite_code: string | null; created_at: string; updated_at: string; deleted_at: string | null;\n  reputation: number; shrimp_coins: number;\n  onboarding_completed: number;\n  custom_name: string | null; custom_avatar: string | null;\n  provider_name: string | null; provider_avatar: string | null;\n}\n\nexport function findUserByProvider(provider: string, providerId: string): DbUser | null {\n  return (getDb().prepare('SELECT * FROM users WHERE provider = ? AND provider_id = ?').get(provider, providerId) as DbUser | undefined) ?? null;\n}\n\nexport function findUserById(id: string): DbUser | null {\n  return (getDb().prepare('SELECT * FROM users WHERE id = ?').get(id) as DbUser | undefined) ?? null;\n}\n\nexport function createUser(data: { id: string; email: string | null; name: string; avatar: string; provider: string; providerId: string; }): DbUser {\n  const now = new Date().toISOString();\n  getDb().prepare(`INSERT INTO users (id,email,name,avatar,provider,provider_id,bio,invite_code,created_at,updated_at,reputation,shrimp_coins,onboarding_completed,provider_name,provider_avatar) VALUES (?,?,?,?,?,?,'',NULL,?,?,0,?,0,?,?)`).run(data.id, data.email, data.name, data.avatar, data.provider, data.providerId, now, now, SHRIMP_COIN_EVENTS.register, data.name, data.avatar);\n\n  // Record the welcome bonus in coin_events\n  addCoins(data.id, 'shrimp_coin', 0, 'register_bonus'); // balance already set to 100 above, just log it\n\n  return findUserById(data.id)!;\n}\n\nexport function softDeleteUser(id: string): boolean {\n  const now = new Date().toISOString();\n  return getDb().prepare('UPDATE users SET deleted_at = ?, updated_at = ? WHERE id = ? AND deleted_at IS NULL').run(now, now, id).changes > 0;\n}\n\nexport function completeOnboarding(userId: string, data: { name: string; avatar: string }): boolean {\n  const now = new Date().toISOString();\n  const db = getDb();\n  return db.prepare('UPDATE users SET name = ?, avatar = ?, custom_name = ?, custom_avatar = ?, onboarding_completed = 1, updated_at = ? WHERE id = ?')\n    .run(data.name, data.avatar, data.name, data.avatar, now, userId).changes > 0;\n}\n\nexport function isOnboardingCompleted(userId: string): boolean {\n  const row = getDb().prepare('SELECT onboarding_completed FROM users WHERE id = ?').get(userId) as { onboarding_completed: number } | undefined;\n  return !!row?.onboarding_completed;\n}\n\nexport function getUserProviderInfo(userId: string): { provider: string; providerName: string | null; providerAvatar: string | null } | null {\n  const row = getDb().prepare('SELECT provider, provider_name, provider_avatar FROM users WHERE id = ?').get(userId) as { provider: string; provider_name: string | null; provider_avatar: string | null } | undefined;\n  return row ? { provider: row.provider, providerName: row.provider_name, providerAvatar: row.provider_avatar } : null;\n}\n\nexport function updateProviderInfo(userId: string, name: string, avatar: string): void {\n  getDb().prepare('UPDATE users SET provider_name = ?, provider_avatar = ?, updated_at = ? WHERE id = ?')\n    .run(name, avatar, new Date().toISOString(), userId);\n}\n\nexport function findUserByEmail(email: string): DbUser | null {\n  return (getDb().prepare('SELECT * FROM users WHERE email = ?').get(email) as DbUser | undefined) ?? null;\n}\n\n// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n// Verification Tokens (for Magic Link email login)\n// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n\nexport function createVerificationToken(data: { identifier: string; token: string; expires: Date }): { identifier: string; token: string; expires: Date } {\n  getDb().prepare('INSERT OR REPLACE INTO verification_tokens (identifier, token, expires) VALUES (?, ?, ?)').run(data.identifier, data.token, data.expires.toISOString());\n  return data;\n}\n\nexport function useVerificationToken(data: { identifier: string; token: string }): { identifier: string; token: string; expires: Date } | null {\n  const db = getDb();\n  const row = db.prepare('SELECT * FROM verification_tokens WHERE identifier = ? AND token = ?').get(data.identifier, data.token) as { identifier: string; token: string; expires: string } | undefined;\n  if (!row) return null;\n  db.prepare('DELETE FROM verification_tokens WHERE identifier = ? AND token = ?').run(data.identifier, data.token);\n  return { identifier: row.identifier, token: row.token, expires: new Date(row.expires) };\n}\n\nexport function activateInviteCode(userId: string, code: string): { success: boolean; error?: string } {\n  const db = getDb();\n  const user = findUserById(userId);\n  if (!user) return { success: false, error: 'ç”¨æˆ·ä¸å­˜åœ¨' };\n  if (user.invite_code) return { success: false, error: 'å·²æ¿€æ´»é‚€è¯·ç ' };\n  const invite = db.prepare('SELECT * FROM invite_codes WHERE code = ?').get(code) as { code: string; max_uses: number; use_count: number; expires_at: string | null } | undefined;\n  if (!invite) return { success: false, error: 'é‚€è¯·ç ä¸å­˜åœ¨' };\n  if (invite.use_count >= invite.max_uses) return { success: false, error: 'é‚€è¯·ç å·²ç”¨å®Œ' };\n  if (invite.expires_at && new Date(invite.expires_at) < new Date()) return { success: false, error: 'é‚€è¯·ç å·²è¿‡æœŸ' };\n  const now = new Date().toISOString();\n  db.transaction(() => {\n    db.prepare('UPDATE users SET invite_code = ?, updated_at = ? WHERE id = ?').run(code, now, userId);\n    db.prepare('UPDATE invite_codes SET use_count = use_count + 1, used_at = ? WHERE code = ?').run(now, code);\n    // Auto-generate 6 invite codes for the newly activated user\n    generateUserInviteCodes(userId);\n  })();\n\n  // Award coins to the invite code creator\n  const inviteDetail = db.prepare('SELECT created_by FROM invite_codes WHERE code = ?').get(code) as { created_by: string } | undefined;\n  if (inviteDetail?.created_by && inviteDetail.created_by !== 'system') {\n    addCoins(inviteDetail.created_by, 'reputation', USER_REP_EVENTS.invite_user, 'invite_user', userId);\n    addCoins(inviteDetail.created_by, 'shrimp_coin', SHRIMP_COIN_EVENTS.invite_user, 'invite_user', userId);\n  }\n\n  return { success: true };\n}\n\nexport function validateInviteCode(code: string): { valid: boolean; error?: string } {\n  const invite = getDb().prepare('SELECT * FROM invite_codes WHERE code = ?').get(code) as { code: string; max_uses: number; use_count: number; expires_at: string | null } | undefined;\n  if (!invite) return { valid: false, error: 'é‚€è¯·ç ä¸å­˜åœ¨' };\n  if (invite.use_count >= invite.max_uses) return { valid: false, error: 'é‚€è¯·ç å·²ç”¨å®Œ' };\n  if (invite.expires_at && new Date(invite.expires_at) < new Date()) return { valid: false, error: 'é‚€è¯·ç å·²è¿‡æœŸ' };\n  return { valid: true };\n}\n\n// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n// Invite Code System â€” Generate / Query / Admin\n// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n\n/** Generate a random 7-char uppercase letter invite code */\nfunction generateInviteCode(): string {\n  const chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ';\n  let code = '';\n  for (let i = 0; i < 7; i++) {\n    code += chars.charAt(Math.floor(Math.random() * chars.length));\n  }\n  return code;\n}\n\nexport interface InviteCode {\n  code: string;\n  createdBy: string;\n  usedBy: string | null;\n  usedAt: string | null;\n  maxUses: number;\n  useCount: number;\n  expiresAt: string | null;\n  type: string;\n  createdAt: string;\n}\n\ninterface DbInviteCode {\n  code: string;\n  created_by: string;\n  used_by: string | null;\n  used_at: string | null;\n  max_uses: number;\n  use_count: number;\n  expires_at: string | null;\n  type: string;\n  created_at: string;\n}\n\nfunction dbInviteToInvite(row: DbInviteCode): InviteCode {\n  return {\n    code: row.code,\n    createdBy: row.created_by,\n    usedBy: row.used_by,\n    usedAt: row.used_at,\n    maxUses: row.max_uses,\n    useCount: row.use_count,\n    expiresAt: row.expires_at,\n    type: row.type,\n    createdAt: row.created_at,\n  };\n}\n\n/** Generate 6 one-time invite codes for a user (called after activation) */\nexport function generateUserInviteCodes(userId: string): string[] {\n  const db = getDb();\n  const now = new Date().toISOString();\n  const codes: string[] = [];\n  const insert = db.prepare(\n    `INSERT OR IGNORE INTO invite_codes (code, created_by, max_uses, use_count, type, created_at) VALUES (?, ?, 1, 0, 'normal', ?)`\n  );\n  let attempts = 0;\n  while (codes.length < 6 && attempts < 30) {\n    const code = generateInviteCode();\n    const result = insert.run(code, userId, now);\n    if (result.changes > 0) {\n      codes.push(code);\n    }\n    attempts++;\n  }\n  return codes;\n}\n\n/** Get all invite codes created by a user */\nexport function getUserInviteCodes(userId: string): InviteCode[] {\n  const rows = getDb().prepare('SELECT * FROM invite_codes WHERE created_by = ? ORDER BY created_at DESC').all(userId) as DbInviteCode[];\n  return rows.map(dbInviteToInvite);\n}\n\n/** Create a super invite code (admin) */\nexport function createSuperInviteCode(code: string, maxUses: number, createdBy: string): boolean {\n  const db = getDb();\n  const now = new Date().toISOString();\n  try {\n    db.prepare(\n      `INSERT INTO invite_codes (code, created_by, max_uses, use_count, type, created_at) VALUES (?, ?, ?, 0, 'super', ?)`\n    ).run(code, createdBy, maxUses, now);\n    return true;\n  } catch {\n    return false; // code already exists\n  }\n}\n\n/** Get invite code detail */\nexport function getInviteCodeDetail(code: string): InviteCode | null {\n  const row = getDb().prepare('SELECT * FROM invite_codes WHERE code = ?').get(code) as DbInviteCode | undefined;\n  return row ? dbInviteToInvite(row) : null;\n}\n\n/** List all invite codes (admin, with pagination and optional type filter) */\nexport function listAllInviteCodes(params?: { type?: string; page?: number; pageSize?: number }): { codes: InviteCode[]; total: number } {\n  const db = getDb();\n  const conditions: string[] = [];\n  const bindings: Record<string, string | number> = {};\n\n  if (params?.type) {\n    conditions.push('type = @type');\n    bindings.type = params.type;\n  }\n\n  const where = conditions.length > 0 ? 'WHERE ' + conditions.join(' AND ') : '';\n  const total = (db.prepare(`SELECT COUNT(*) as cnt FROM invite_codes ${where}`).get(bindings) as { cnt: number }).cnt;\n\n  const page = Math.max(1, params?.page ?? 1);\n  const pageSize = Math.min(100, Math.max(1, params?.pageSize ?? 20));\n  const offset = (page - 1) * pageSize;\n\n  const rows = db.prepare(`SELECT * FROM invite_codes ${where} ORDER BY created_at DESC LIMIT @limit OFFSET @offset`).all({ ...bindings, limit: pageSize, offset }) as DbInviteCode[];\n  return { codes: rows.map(dbInviteToInvite), total };\n}\n\n/** Delete an invite code (admin) */\nexport function deleteInviteCode(code: string): boolean {\n  return getDb().prepare('DELETE FROM invite_codes WHERE code = ?').run(code).changes > 0;\n}\n\n/** Check if a user has activated an invite code (has publish/comment access) */\nexport function userHasInviteAccess(userId: string): boolean {\n  const user = findUserById(userId);\n  return !!user?.invite_code;\n}\n\n// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n// Public API â€” Authorized Devices\n// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n\nexport function authorizeDevice(userId: string, deviceId: string, name: string = ''): boolean {\n  const now = new Date().toISOString();\n  getDb().prepare('INSERT OR REPLACE INTO authorized_devices (device_id, user_id, name, authorized_at) VALUES (?, ?, ?, ?)').run(deviceId, userId, name, now);\n  return true;\n}\n\nexport function validateDevice(deviceId: string): { userId: string; name: string } | null {\n  const row = getDb().prepare('SELECT user_id, name FROM authorized_devices WHERE device_id = ?').get(deviceId) as { user_id: string; name: string } | undefined;\n  if (!row) return null;\n  getDb().prepare('UPDATE authorized_devices SET last_publish_at = ? WHERE device_id = ?').run(new Date().toISOString(), deviceId);\n  return { userId: row.user_id, name: row.name };\n}\n\nexport function listAuthorizedDevices(userId: string): { deviceId: string; name: string; authorizedAt: string; lastPublishAt: string | null }[] {\n  const rows = getDb().prepare('SELECT device_id, name, authorized_at, last_publish_at FROM authorized_devices WHERE user_id = ?').all(userId) as { device_id: string; name: string; authorized_at: string; last_publish_at: string | null }[];\n  return rows.map(r => ({\n    deviceId: r.device_id.slice(0, 12) + '...',\n    name: r.name,\n    authorizedAt: r.authorized_at,\n    lastPublishAt: r.last_publish_at,\n  }));\n}\n\nexport function revokeDevice(deviceId: string, userId: string): boolean {\n  const result = getDb().prepare('DELETE FROM authorized_devices WHERE device_id = ? AND user_id = ?').run(deviceId, userId);\n  return result.changes > 0;\n}\n\n// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n// Public API â€” User Profiles\n// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n\nexport interface DbUserProfile {\n  id: string; name: string; avatar: string; bio: string; joined_at: string;\n  published_assets: string; favorite_assets: string;\n  followers: number; following: number; is_agent: number;\n  agent_model: string | null; agent_uptime: string | null; agent_tasks_completed: number;\n  agent_specialization: string | null; contribution_points: number;\n  contributor_level: string; instance_id: string | null;\n}\n\nfunction profileRowToUser(row: DbUserProfile): User {\n  const isAgent = !!row.is_agent;\n  return {\n    id: row.id, name: row.name, avatar: row.avatar, bio: row.bio, joinedAt: row.joined_at,\n    publishedAssets: JSON.parse(row.published_assets),\n    favoriteAssets: JSON.parse(row.favorite_assets),\n    followers: row.followers, following: row.following, isAgent: isAgent,\n    agentConfig: isAgent ? {\n      model: row.agent_model || '', uptime: row.agent_uptime || '',\n      tasksCompleted: row.agent_tasks_completed,\n      specialization: row.agent_specialization ? JSON.parse(row.agent_specialization) : [],\n    } : undefined,\n    contributionPoints: row.contribution_points,\n    contributorLevel: row.contributor_level as User['contributorLevel'],\n    instanceId: row.instance_id ?? undefined,\n  };\n}\n\nexport function getUserProfile(id: string): User | null {\n  const row = getDb().prepare('SELECT * FROM user_profiles WHERE id = ?').get(id) as DbUserProfile | undefined;\n  return row ? profileRowToUser(row) : null;\n}\n\nexport function listUserProfiles(): User[] {\n  const rows = getDb().prepare('SELECT * FROM user_profiles ORDER BY followers DESC').all() as DbUserProfile[];\n  return rows.map(profileRowToUser);\n}\n\nexport function searchUserProfiles(query: string): User[] {\n  const rows = getDb().prepare('SELECT * FROM user_profiles WHERE name LIKE ? OR bio LIKE ? ORDER BY followers DESC').all(`%${query}%`, `%${query}%`) as DbUserProfile[];\n  return rows.map(profileRowToUser);\n}\n\nexport function getAgentUserProfiles(): User[] {\n  const rows = getDb().prepare('SELECT * FROM user_profiles WHERE is_agent = 1 ORDER BY followers DESC').all() as DbUserProfile[];\n  return rows.map(profileRowToUser);\n}\n\nexport function listUserProfileIds(): string[] {\n  const rows = getDb().prepare('SELECT id FROM user_profiles').all() as { id: string }[];\n  return rows.map(r => r.id);\n}\n\n// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n// Public API â€” Comments\n// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n\ninterface DbComment {\n  id: string; asset_id: string; user_id: string; user_name: string; user_avatar: string;\n  content: string; rating: number; created_at: string; commenter_type: string;\n}\n\nfunction commentRowToComment(row: DbComment) {\n  return {\n    id: row.id, assetId: row.asset_id, userId: row.user_id, userName: row.user_name,\n    userAvatar: row.user_avatar, content: row.content, rating: row.rating,\n    createdAt: row.created_at, commenterType: row.commenter_type as 'user' | 'agent',\n  };\n}\n\nexport function getCommentsByAssetId(assetId: string) {\n  const rows = getDb().prepare('SELECT * FROM comments WHERE asset_id = ? ORDER BY created_at DESC').all(assetId) as DbComment[];\n  return rows.map(commentRowToComment);\n}\n\nexport function createComment(data: { assetId: string; userId: string; userName: string; userAvatar: string; content: string; rating: number; commenterType?: string }) {\n  const db = getDb();\n  const id = 'cm-' + Math.random().toString(36).substring(2, 8);\n  const now = new Date().toISOString().split('T')[0];\n  db.prepare(`INSERT INTO comments (id,asset_id,user_id,user_name,user_avatar,content,rating,created_at,commenter_type) VALUES (?,?,?,?,?,?,?,?,?)`).run(id, data.assetId, data.userId, data.userName, data.userAvatar, data.content, data.rating, now, data.commenterType ?? 'user');\n\n  // Award coins to commenter\n  addCoins(data.userId, 'reputation', USER_REP_EVENTS.write_comment, 'write_comment', data.assetId);\n  addCoins(data.userId, 'shrimp_coin', SHRIMP_COIN_EVENTS.write_comment, 'write_comment', data.assetId);\n\n  // Award coins to asset author for receiving a comment/rating\n  const asset = db.prepare('SELECT author_id FROM assets WHERE id = ?').get(data.assetId) as { author_id: string } | undefined;\n  if (asset?.author_id && asset.author_id !== data.userId) {\n    if (data.rating >= 4) {\n      addCoins(asset.author_id, 'reputation', USER_REP_EVENTS.asset_rated_good, 'asset_rated_good', data.assetId);\n    }\n    if (data.rating === 5) {\n      addCoins(asset.author_id, 'shrimp_coin', SHRIMP_COIN_EVENTS.asset_rated_5star, 'asset_rated_5star', data.assetId);\n    }\n  }\n\n  // Recalculate hub score after rating\n  recalculateHubScore(data.assetId);\n\n  return { id, ...data, createdAt: now };\n}\n\nexport function getCommentCount(assetId: string): number {\n  return (getDb().prepare('SELECT COUNT(*) as cnt FROM comments WHERE asset_id = ?').get(assetId) as { cnt: number }).cnt;\n}\n\n// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n// Public API â€” Issues\n// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n\ninterface DbIssue {\n  id: string; asset_id: string; author_id: string; author_name: string; author_avatar: string;\n  author_type: string; title: string; body: string; status: string;\n  labels: string; created_at: string; comment_count: number;\n}\n\nfunction issueRowToIssue(row: DbIssue) {\n  return {\n    id: row.id, assetId: row.asset_id, authorId: row.author_id, authorName: row.author_name,\n    authorAvatar: row.author_avatar, authorType: row.author_type as 'user' | 'agent',\n    title: row.title, body: row.body, status: row.status as 'open' | 'closed',\n    labels: JSON.parse(row.labels) as string[], createdAt: row.created_at,\n    commentCount: row.comment_count,\n  };\n}\n\nexport function getIssuesByAssetId(assetId: string) {\n  const rows = getDb().prepare('SELECT * FROM issues WHERE asset_id = ? ORDER BY created_at DESC').all(assetId) as DbIssue[];\n  return rows.map(issueRowToIssue);\n}\n\nexport function createIssue(data: { assetId: string; authorId: string; authorName: string; authorAvatar: string; authorType?: string; title: string; body: string; labels?: string[] }) {\n  const db = getDb();\n  const id = 'is-' + Math.random().toString(36).substring(2, 8);\n  const now = new Date().toISOString().split('T')[0];\n  db.prepare(`INSERT INTO issues (id,asset_id,author_id,author_name,author_avatar,author_type,title,body,status,labels,created_at,comment_count) VALUES (?,?,?,?,?,?,?,?,?,?,?,?)`).run(id, data.assetId, data.authorId, data.authorName, data.authorAvatar, data.authorType ?? 'user', data.title, data.body, 'open', JSON.stringify(data.labels ?? []), now, 0);\n\n  // Award coins to issue submitter\n  addCoins(data.authorId, 'reputation', USER_REP_EVENTS.submit_issue, 'submit_issue', data.assetId);\n  addCoins(data.authorId, 'shrimp_coin', SHRIMP_COIN_EVENTS.submit_issue, 'submit_issue', data.assetId);\n\n  return { id, ...data, status: 'open', createdAt: now, commentCount: 0 };\n}\n\nexport function searchIssues(query: string) {\n  const rows = getDb().prepare('SELECT * FROM issues WHERE title LIKE ? OR body LIKE ? ORDER BY created_at DESC').all(`%${query}%`, `%${query}%`) as DbIssue[];\n  return rows.map(issueRowToIssue);\n}\n\nexport function getIssueCount(assetId: string): number {\n  return (getDb().prepare('SELECT COUNT(*) as cnt FROM issues WHERE asset_id = ?').get(assetId) as { cnt: number }).cnt;\n}\n\n// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n// Public API â€” Collections\n// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n\ninterface DbCollection {\n  id: string; title: string; description: string; curator_id: string;\n  curator_name: string; curator_avatar: string; asset_ids: string;\n  cover_emoji: string; followers: number; created_at: string;\n}\n\nfunction collectionRowToCollection(row: DbCollection) {\n  return {\n    id: row.id, title: row.title, description: row.description,\n    curatorId: row.curator_id, curatorName: row.curator_name, curatorAvatar: row.curator_avatar,\n    assetIds: JSON.parse(row.asset_ids) as string[], coverEmoji: row.cover_emoji,\n    followers: row.followers, createdAt: row.created_at,\n  };\n}\n\nexport function getCollections() {\n  const rows = getDb().prepare('SELECT * FROM collections ORDER BY followers DESC').all() as DbCollection[];\n  return rows.map(collectionRowToCollection);\n}\n\nexport function searchCollections(query: string) {\n  const rows = getDb().prepare('SELECT * FROM collections WHERE title LIKE ? OR description LIKE ? ORDER BY followers DESC').all(`%${query}%`, `%${query}%`) as DbCollection[];\n  return rows.map(collectionRowToCollection);\n}\n\n// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n// Public API â€” Notifications\n// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n\ninterface DbNotification {\n  id: string; user_id: string; type: string; title: string; message: string;\n  icon: string; link_to: string | null; is_read: number; created_at: string;\n}\n\nfunction notifRowToNotif(row: DbNotification) {\n  return {\n    id: row.id, type: row.type as 'comment' | 'issue' | 'download' | 'follower',\n    title: row.title, message: row.message, icon: row.icon,\n    linkTo: row.link_to ?? undefined, read: !!row.is_read, createdAt: row.created_at,\n  };\n}\n\nexport function getNotifications(userId: string = 'self') {\n  const rows = getDb().prepare('SELECT * FROM notifications WHERE user_id = ? ORDER BY created_at DESC').all(userId) as DbNotification[];\n  return rows.map(notifRowToNotif);\n}\n\nexport function markNotificationRead(id: string) {\n  getDb().prepare('UPDATE notifications SET is_read = 1 WHERE id = ?').run(id);\n}\n\nexport function markAllRead(userId: string = 'self') {\n  getDb().prepare('UPDATE notifications SET is_read = 1 WHERE user_id = ?').run(userId);\n}\n\n// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n// Public API â€” Evolution & Activity Events\n// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n\ninterface DbEvolutionEvent {\n  id: string; user_id: string; icon: string; title: string;\n  description: string; date: string; type: string;\n}\n\nexport function getEvolutionEventsByUserId(userId: string) {\n  const rows = getDb().prepare('SELECT * FROM evolution_events WHERE user_id = ? ORDER BY date ASC').all(userId) as DbEvolutionEvent[];\n  return rows.map(r => ({ id: r.id, userId: r.user_id, icon: r.icon, title: r.title, description: r.description, date: r.date, type: r.type }));\n}\n\ninterface DbActivityEvent {\n  id: string; user_id: string; icon: string; text: string;\n  date: string; type: string; link_to: string | null; actor_type: string;\n}\n\nexport function getActivityEventsByUserId(userId: string) {\n  const rows = getDb().prepare('SELECT * FROM activity_events WHERE user_id = ? ORDER BY date DESC').all(userId) as DbActivityEvent[];\n  return rows.map(r => ({ id: r.id, userId: r.user_id, icon: r.icon, text: r.text, date: r.date, type: r.type, linkTo: r.link_to ?? undefined, actorType: r.actor_type as 'user' | 'agent' }));\n}\n\n// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n// Public API â€” Growth / Stats\n// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n\nexport function getGrowthData() {\n  const rows = getDb().prepare('SELECT * FROM daily_stats ORDER BY day ASC').all() as { day: number; downloads: number; new_assets: number; new_users: number }[];\n  return rows.map(r => ({ day: r.day, downloads: r.downloads, newAssets: r.new_assets, newUsers: r.new_users }));\n}\n\nexport interface StatsData {\n  totalAssets: number; totalDevelopers: number; totalDownloads: number; weeklyNew: number;\n  topDevelopers: { id: string; name: string; avatar: string; assetCount: number; totalDownloads: number }[];\n  recentActivity: { type: 'publish' | 'update'; authorName: string; authorAvatar: string; assetName: string; assetDisplayName: string; version: string; timestamp: string }[];\n}\n\nexport function getStats(): StatsData {\n  const db = getDb();\n  const totalAssets = (db.prepare('SELECT COUNT(*) as cnt FROM assets').get() as { cnt: number }).cnt;\n  const totalDevelopers = (db.prepare(\"SELECT COUNT(DISTINCT author_id) as cnt FROM assets WHERE author_id != ''\").get() as { cnt: number }).cnt;\n  const totalDownloads = (db.prepare('SELECT COALESCE(SUM(downloads), 0) as total FROM assets').get() as { total: number }).total;\n  const sevenDaysAgo = new Date(Date.now() - 7 * 24 * 60 * 60 * 1000).toISOString().split('T')[0];\n  const weeklyNew = (db.prepare('SELECT COUNT(*) as cnt FROM assets WHERE created_at >= ?').get(sevenDaysAgo) as { cnt: number }).cnt;\n\n  const topDevelopers = db.prepare(`SELECT author_id as id, author_name as name, author_avatar as avatar, COUNT(*) as assetCount, COALESCE(SUM(downloads),0) as totalDownloads FROM assets WHERE author_id != '' GROUP BY author_id ORDER BY totalDownloads DESC LIMIT 10`).all() as { id: string; name: string; avatar: string; assetCount: number; totalDownloads: number }[];\n\n  const recentRows = db.prepare(`SELECT name, display_name, author_name, author_avatar, version, created_at, updated_at FROM assets ORDER BY updated_at DESC LIMIT 20`).all() as { name: string; display_name: string; author_name: string; author_avatar: string; version: string; created_at: string; updated_at: string }[];\n  const recentActivity = recentRows.map(row => ({\n    type: (row.created_at === row.updated_at ? 'publish' : 'update') as 'publish' | 'update',\n    authorName: row.author_name, authorAvatar: row.author_avatar,\n    assetName: row.name, assetDisplayName: row.display_name,\n    version: row.version, timestamp: row.updated_at,\n  }));\n\n  return { totalAssets, totalDevelopers, totalDownloads, weeklyNew, topDevelopers, recentActivity };\n}\n\nexport function getAssetCountByType(): Record<string, number> {\n  const rows = getDb().prepare('SELECT type, COUNT(*) as cnt FROM assets GROUP BY type').all() as { type: string; cnt: number }[];\n  const result: Record<string, number> = {};\n  for (const row of rows) result[row.type] = row.cnt;\n  return result;\n}\n\nexport function getTotalCommentCount(): number {\n  return (getDb().prepare('SELECT COUNT(*) as cnt FROM comments').get() as { cnt: number }).cnt;\n}\n\nexport function getTotalIssueCount(): number {\n  return (getDb().prepare('SELECT COUNT(*) as cnt FROM issues').get() as { cnt: number }).cnt;\n}\n\nexport function getTotalUserCount(): number {\n  return (getDb().prepare('SELECT COUNT(*) as cnt FROM user_profiles').get() as { cnt: number }).cnt;\n}\n\n// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n// V1 API helpers\n// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n\nexport interface AssetCompact {\n  id: string; name: string; displayName: string; type: string;\n  description: string; tags: string[]; installs: number; rating: number;\n  author: string; authorId: string; version: string;\n  installCommand: string; updatedAt: string; category: string;\n}\n\nexport function listAssetsCompact(params: ListParams & { tag?: string }): { assets: AssetCompact[]; total: number; page: number; pageSize: number } {\n  const db = getDb();\n  const conditions: string[] = [];\n  const bindings: Record<string, string | number> = {};\n\n  if (params.type && ['skill','config','plugin','trigger','channel','template'].includes(params.type)) {\n    conditions.push('type = @type'); bindings.type = params.type;\n  }\n  if (params.category) { conditions.push('category = @category'); bindings.category = params.category; }\n  if (params.tag) {\n    conditions.push('tags LIKE @tag');\n    bindings.tag = `%\"${params.tag}\"%`;\n  }\n  if (params.q) {\n    conditions.push(`(name LIKE @q OR display_name LIKE @q OR description LIKE @q OR tags LIKE @q)`);\n    bindings.q = `%${params.q}%`;\n  }\n  const where = conditions.length > 0 ? 'WHERE ' + conditions.join(' AND ') : '';\n  const total = (db.prepare(`SELECT COUNT(*) as cnt FROM assets ${where}`).get(bindings) as { cnt: number }).cnt;\n\n  let orderBy: string;\n  switch (params.sort) {\n    case 'installs': case 'downloads': orderBy = 'downloads DESC'; break;\n    case 'rating': orderBy = 'rating DESC'; break;\n    case 'newest': case 'updated_at': orderBy = 'updated_at DESC'; break;\n    case 'created_at': orderBy = 'created_at DESC'; break;\n    default: orderBy = 'downloads DESC, updated_at DESC';\n  }\n  const page = Math.max(1, params.page ?? 1);\n  const pageSize = Math.min(100, Math.max(1, params.pageSize ?? 20));\n  const offset = (page - 1) * pageSize;\n\n  const rows = db.prepare(`SELECT id, name, display_name, type, description, tags, downloads, rating, author_name, author_id, version, install_command, updated_at, category FROM assets ${where} ORDER BY ${orderBy} LIMIT @limit OFFSET @offset`).all({ ...bindings, limit: pageSize, offset }) as {\n    id: string; name: string; display_name: string; type: string; description: string;\n    tags: string; downloads: number; rating: number; author_name: string; author_id: string;\n    version: string; install_command: string; updated_at: string; category: string;\n  }[];\n\n  return {\n    assets: rows.map(r => ({\n      id: r.id, name: r.name, displayName: r.display_name, type: r.type,\n      description: r.description, tags: JSON.parse(r.tags), installs: r.downloads,\n      rating: r.rating, author: r.author_name, authorId: r.author_id, version: r.version,\n      installCommand: r.install_command, updatedAt: r.updated_at, category: r.category,\n    })),\n    total, page, pageSize,\n  };\n}\n\nexport function getAllTags(): { name: string; count: number }[] {\n  const db = getDb();\n  const rows = db.prepare('SELECT tags FROM assets').all() as { tags: string }[];\n  const tagMap = new Map<string, number>();\n  for (const row of rows) {\n    const tags = JSON.parse(row.tags) as string[];\n    for (const t of tags) {\n      tagMap.set(t, (tagMap.get(t) ?? 0) + 1);\n    }\n  }\n  return [...tagMap.entries()]\n    .map(([name, count]) => ({ name, count }))\n    .sort((a, b) => b.count - a.count);\n}\n\nexport function getAllCategories(): { name: string; count: number }[] {\n  const rows = getDb().prepare(\"SELECT category, COUNT(*) as cnt FROM assets WHERE category != '' GROUP BY category ORDER BY cnt DESC\").all() as { category: string; cnt: number }[];\n  return rows.map(r => ({ name: r.category, count: r.cnt }));\n}\n\nexport function getAssetManifest(id: string): { id: string; manifest: Record<string, unknown> } | null {\n  const row = getDb().prepare('SELECT id, manifest FROM assets WHERE id = ?').get(id) as { id: string; manifest: string } | undefined;\n  if (!row) return null;\n  return { id: row.id, manifest: JSON.parse(row.manifest || '{}') };\n}\n\nexport function updateAssetManifest(id: string, manifest: Record<string, unknown>): boolean {\n  return getDb().prepare('UPDATE assets SET manifest = ? WHERE id = ?').run(JSON.stringify(manifest), id).changes > 0;\n}\n\nexport function getAssetReadme(id: string): { name: string; displayName: string; readme: string; version: string } | null {\n  const row = getDb().prepare('SELECT name, display_name, readme, version FROM assets WHERE id = ?').get(id) as { name: string; display_name: string; readme: string; version: string } | undefined;\n  if (!row) return null;\n  return { name: row.name, displayName: row.display_name, readme: row.readme, version: row.version };\n}\n\nexport function getAssetsByIds(ids: string[]): AssetCompact[] {\n  if (ids.length === 0) return [];\n  const db = getDb();\n  const placeholders = ids.map(() => '?').join(',');\n  const rows = db.prepare(`SELECT id, name, display_name, type, description, tags, downloads, rating, author_name, author_id, version, install_command, updated_at, category FROM assets WHERE id IN (${placeholders})`).all(...ids) as {\n    id: string; name: string; display_name: string; type: string; description: string;\n    tags: string; downloads: number; rating: number; author_name: string; author_id: string;\n    version: string; install_command: string; updated_at: string; category: string;\n  }[];\n  return rows.map(r => ({\n    id: r.id, name: r.name, displayName: r.display_name, type: r.type,\n    description: r.description, tags: JSON.parse(r.tags), installs: r.downloads,\n    rating: r.rating, author: r.author_name, authorId: r.author_id, version: r.version,\n    installCommand: r.install_command, updatedAt: r.updated_at, category: r.category,\n  }));\n}\n\nexport function getTrendingAssets(period: string, limit: number = 10): AssetCompact[] {\n  const db = getDb();\n  // For now, trending = most downloads. With more data, could use time-windowed installs.\n  const rows = db.prepare(`SELECT id, name, display_name, type, description, tags, downloads, rating, author_name, author_id, version, install_command, updated_at, category FROM assets ORDER BY downloads DESC, updated_at DESC LIMIT ?`).all(Math.min(limit, 50)) as {\n    id: string; name: string; display_name: string; type: string; description: string;\n    tags: string; downloads: number; rating: number; author_name: string; author_id: string;\n    version: string; install_command: string; updated_at: string; category: string;\n  }[];\n  return rows.map(r => ({\n    id: r.id, name: r.name, displayName: r.display_name, type: r.type,\n    description: r.description, tags: JSON.parse(r.tags), installs: r.downloads,\n    rating: r.rating, author: r.author_name, authorId: r.author_id, version: r.version,\n    installCommand: r.install_command, updatedAt: r.updated_at, category: r.category,\n  }));\n}\n","// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n// Seed data â€” imported by db.ts for SQLite seeding\n// Only invite codes remain; all fake data removed.\n// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n\nexport const inviteCodes = [\n  { code: 'SEAFOOD', maxUses: 100, type: 'super' as const },\n  { code: 'OPENCLAW', maxUses: 100, type: 'super' as const },\n  { code: 'AGENTHUB', maxUses: 50, type: 'super' as const },\n];\n"],"names":[],"mappings":"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"}